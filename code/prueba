(* Esto no es un script(aunque se podria hacerlo). Es para copiar en la terminal *)
(* Eliminamos los archivos compilados y volvemos a compilar *)
make clean
make
(* Abrimos mosml *)
mosml
(* Cargamos los archivos *)
load "tigertemp";
load "tigerassem";
load "tigergraph";
load "tigerflow";
load "tigerliveness";
load "String";
load "Splaymap";
load "Int";
load "tigercolor";

(* Creando lista de instrucciones para probar tigerFlow y tigerLiveness*)
val instrs = [tigerassem.IOPER{assem="movq $2, %'d0",dst=["c"],src=[],jump=NONE},           (* c <- 2 *)
              tigerassem.IOPER{assem="movq $0, %'d0",dst=["a"],src=[],jump=NONE},           (* a <- 0 *)
              tigerassem.ILABEL{assem="L1:",lab="L1"},                                      (* L1: *)
              tigerassem.IMOVE{assem="movq %'s0, %'d0",dst="b",src="a"},                    (* b <- a *)
              tigerassem.IOPER{assem="addq $1, %'d0",dst=["b"],src=["b"],jump=NONE},        (* b <- b + 1 *)
              tigerassem.IOPER{assem="addq %'s1, %'d0",dst=["c"],src=["c","b"],jump=NONE},  (* c <- c + b *)
              tigerassem.IMOVE{assem="movq %'s0, %'d0",dst="a",src="b"},                    (* a <- b *)
              tigerassem.IOPER{assem="mulq $2, %'d0",dst=["a"],src=["a"],jump=NONE},        (* a <- a * 2 *)
              tigerassem.IOPER{assem="cmpq %'s0, $5",dst=[],src=["a"],jump=NONE},           (* if a < 5 goto L1 *)
              tigerassem.IOPER{assem="jg 'j0",dst=[],src=[],jump=SOME ["L1","L2"]},
              tigerassem.ILABEL{assem="L2:",lab="L2"},                                      (* L2: *)
              tigerassem.IMOVE{assem="movq $0, %'d0",dst="d",src="c"}                       (* d <- c *)
             ];

(* Ejemplo del libro *)
val instrs = [tigerassem.IOPER{assem="movq $2, %'d0",dst=["c"],src=[],jump=NONE},           (* c <- 2 *)
              tigerassem.IOPER{assem="movq $0, %'d0",dst=["a"],src=[],jump=NONE},           (* a <- 0 *)
              tigerassem.ILABEL{assem="L1:",lab="L1"},                                      (* L1: *)
              tigerassem.IOPER{assem="addq $1, %'d0",dst=["b"],src=["a"],jump=NONE},        (* b <- a + 1 *)
              tigerassem.IOPER{assem="addq %'s1, %'d0",dst=["c"],src=["c","b"],jump=NONE},  (* c <- c + b *)
              tigerassem.IOPER{assem="mulq $2, %'d0",dst=["a"],src=["b"],jump=NONE},        (* a <- b * 2 *)
              tigerassem.IOPER{assem="cmpq %'s0, $5",dst=[],src=["a"],jump=NONE},           (* if a < 5 goto L1 *)
              tigerassem.IOPER{assem="jg 'j0",dst=[],src=[],jump=SOME ["L1","L2"]},
              tigerassem.ILABEL{assem="L2:",lab="L2"},                                      (* L2: *)
              tigerassem.IMOVE{assem="movq $0, %'d0",dst="d",src="c"}                       (* d <- c *)
             ];

(* Otro ejemplo del libro 
   Solo se tienen en cuenta los dst y src (las instrucciones assem no representan nada) *)
val instrs = [tigerassem.IOPER{assem="movq $2, %'d0",dst=["b"],src=[],jump=NONE},           (* b <- 2 *)
              tigerassem.IOPER{assem="movq $2, %'d0",dst=["a"],src=["b"],jump=NONE},        (* a <- b * b *)
              tigerassem.IOPER{assem="movq $2, %'d0",dst=["c"],src=["a","b"],jump=NONE},    (* c <- a + b *)
              tigerassem.IOPER{assem="cmpq %'s0, '%'s1",dst=[],src=["a","b"],jump=NONE},    (* if a >= b goto L1 *)
              tigerassem.IOPER{assem="jle 'j0",dst=[],src=[],jump=SOME ["L1","L2"]},
              tigerassem.ILABEL{assem="L1:",lab="L1"},                                      (* L1: *)
              tigerassem.IMOVE{assem="movq $0, %'d0",dst="d",src="a"},                      (* d <- a *)
              tigerassem.ILABEL{assem="L2:",lab="L2"},                                      (* L2: *)
              tigerassem.IMOVE{assem="movq $0, %'d0",dst="d",src="c"}                       (* d <- c *)
             ];

(* Ejemplo libro coloreo *)
val instrs = [tigerassem.IMOVE{assem="movq %'s0, %'d0",dst="c",src="r3"},                   (* c <- r3 *)
              tigerassem.IMOVE{assem="movq %'s0, %'d0",dst="a",src="r1"},                   (* a <- r1 *)
              tigerassem.IMOVE{assem="movq %'s0, %'d0",dst="b",src="r2"},                   (* b <- r2 *)
              tigerassem.IOPER{assem="movq $0, %'d0",dst=["d"],src=[],jump=NONE},           (* d <- 0 *)
              tigerassem.IMOVE{assem="movq %'s0, %'d0",dst="e",src="a"},                    (* e <- a *)
              tigerassem.ILABEL{assem="loop:",lab="loop"},                                  (* loop: *)
              tigerassem.IOPER{assem="addq %'s1, %'d0",dst=["d"],src=["d","b"],jump=NONE},  (* d <- d + b *)
              tigerassem.IOPER{assem="subq $1, %'d0",dst=["e"],src=["e"],jump=NONE},        (* e <- e - 1 *)
              tigerassem.IOPER{assem="cmpq $0, %'s0",dst=[],src=["e"],jump=NONE},          (* if e > 0 goto loop *)
              tigerassem.IOPER{assem="jle 'j0",dst=[],src=[],jump=SOME ["loop","sigue"]},
              tigerassem.ILABEL{assem="sigue:",lab="sigue"},                                (* sigue: *)
              tigerassem.IMOVE{assem="movq %'s0, %'d0",dst="r1",src="d"},                   (* r1 <- d *)
              tigerassem.IMOVE{assem="movq %'s0, %'d0",dst="r3",src="c"}                    (* r3 <- c *)
             ];

(* Funcion fact *)
val instrs = [tigerassem.ILABEL{assem="fact:",lab="fact"},(* fact: *)
              tigerassem.IOPER{assem="pushq %'s0",dst=[],src=["rbp"],jump=NONE},             (* pushq %rbp *)
              tigerassem.IMOVE{assem="movq %'s0, %'d0",dst="rbp",src="rsp"},                 (* movq %rsp, %rbp *)
              tigerassem.IOPER{assem="subq $0, %'d0",dst=["rsp"],src=["rsp"],jump=NONE},     (* subq $0, %rsp *)
              tigerassem.ILABEL{assem="L4:",lab="L4"},                                       (* L4: *)
              tigerassem.IOPER{assem="movq $0, %'d0",dst=["T9"],src=[],jump=NONE},           (* movq $0, %T9 *)
              tigerassem.IOPER{assem="cmpq %'s0, %'s1",dst=[],src=["T0","T9"],jump=NONE},    (* cmpq %T0, %T9 *)
              tigerassem.IOPER{assem="je 'j0",dst=[],src=[],jump=SOME ["L0"]},               (* je L0 *)
              tigerassem.ILABEL{assem="L1:",lab="L1"},                                       (* L1: *)
              tigerassem.IMOVE{assem="movq %'s0, %'d0",dst="T8",src="T0"},                   (* movq %T0, %T8 *)
              tigerassem.IMOVE{assem="movq %'s0, %'d0",dst="T10",src="T0"},                  (* movq %T0, %T10 *)
              tigerassem.IOPER{assem="movq $1, %'d0",dst=["T11"],src=[],jump=NONE},          (* movq $1, %T11 *)
              tigerassem.IOPER{assem="subq %'s1, %'d0",dst=["T10"],src=["T10","T11"],jump=NONE},(* subq %T11, %T10 *)
              tigerassem.IMOVE{assem="movq %'s0, %'d0",dst="T1",src="T10"},                  (* movq %T10, %T1 *)
              tigerassem.IMOVE{assem="movq %'s0, %'d0",dst="T13",src="rbp"},                 (* movq %rbp, %T13 *)
              tigerassem.IOPER{assem="movq $16, %'d0",dst=["T14"],src=[],jump=NONE},         (* movq $16, %T14 *)
              tigerassem.IOPER{assem="addq %'s1, %'d0",dst=["T13"],src=["T13","T14"],jump=NONE},(* addq %T14, %T13 *)
              tigerassem.IOPER{assem="movq (%'s0), %'d0",dst=["T12"],src=["T13"],jump=NONE}, (* movq (%T13), %T12 *)
              tigerassem.IMOVE{assem="movq %'s0, %'d0",dst="T2",src="T12"},                  (* movq %T12, %T2 *)
              tigerassem.IOPER{assem="xorq %'d1, %'d0",dst=["rax","rax"],src=[],jump=NONE},  (* xorq %rax, %rax *)
              tigerassem.IMOVE{assem="movq %'s0, %'d0",dst="rdi",src="T2"},                  (* movq %T2, %rdi *)
              tigerassem.IMOVE{assem="movq %'s0, %'d0",dst="rsi",src="T1"},                  (* movq %T1, %rsi *)
              tigerassem.IOPER{assem="call fact",dst=["rax", "rcx", "rdx", "rsi", "rdi", "r8", "r9"],src=["rdi"],jump=NONE},(* call fact *)
              tigerassem.IMOVE{assem="movq %'s0, %'d0",dst="T3",src="rax"},                  (* movq %rax, %T3 *)
              tigerassem.IMOVE{assem="movq %'s0, %'d0",dst="T15",src="T8"},                  (* movq %T8, %T15 *)
              tigerassem.IOPER{assem="imulq %'s1, %'d0",dst=["T15"],src=["T15","T3"],jump=NONE},(* imulq %T3, %T15 *)
              tigerassem.IMOVE{assem="movq %'s0, %'d0",dst="T4",src="T15"},                  (* movq %T15, %T4 *)
              tigerassem.ILABEL{assem="L2:",lab="L2"},                                       (* L2 *)
              tigerassem.IMOVE{assem="movq %'s0, %'d0",dst="rax",src="T4"},                  (* movq %T4, %rax *)
              tigerassem.IOPER{assem="jmp 'j0",dst=[],src=[],jump=SOME ["L3"]},              (* jmp L3 *)
              tigerassem.ILABEL{assem="L0:",lab="L0"},                                       (* L0 *)
              tigerassem.IOPER{assem="movq $1, %'d0",dst=["T16"],src=[],jump=NONE},          (* movq $1, %T16 *)
              tigerassem.IMOVE{assem="movq %'s0, %'d0",dst="T4",src="T16"},                  (* movq %T16, %T4 *)
              tigerassem.IOPER{assem="jmp 'j0",dst=[],src=[],jump=SOME ["L2"]},              (* jmp L2 *)
              tigerassem.ILABEL{assem="L3:",lab="L3"},                                       (* L3 *)
              tigerassem.IMOVE{assem="movq %'s0, %'d0",dst="rsp",src="rbp"},                 (* movq %rbp, %rsp *)
              tigerassem.IOPER{assem="popq %'d0",dst=["rbp"],src=[],jump=NONE},              (* popq %rbp *)

              tigerassem.ILABEL{assem="tigermain:",lab="tigermain"},                         (* tigermain: *)
              tigerassem.IOPER{assem="pushq %'s0",dst=[],src=["rbp"],jump=NONE},             (* pushq %rbp *)
              tigerassem.IMOVE{assem="movq %'s0, %'d0",dst="rbp",src="rsp"},                 (* movq %rsp, %rbp *)
              tigerassem.IOPER{assem="subq $0, %'d0",dst=["rsp"],src=["rsp"],jump=NONE},     (* subq $0, %rsp *)
              tigerassem.ILABEL{assem="L6:",lab="L6"},                                       (* L6 *)
              tigerassem.IOPER{assem="movq $3, %'d0",dst=["T17"],src=[],jump=NONE},          (* movq $3, %T17 *)
              tigerassem.IMOVE{assem="movq %'s0, %'d0",dst="T5",src="T17"},                  (* movq %T17, %T5 *)
              tigerassem.IMOVE{assem="movq %'s0, %'d0",dst="T6",src="rbp"},                  (* movq %rbp, %T6 *)
              tigerassem.IOPER{assem="xorq %'d1, %'d0",dst=["rax","rax"],src=[],jump=NONE},  (* xorq %rax, %rax *)
              tigerassem.IMOVE{assem="movq %'s0, %'d0",dst="rdi",src="T6"},                  (* movq %T6, %rdi *)
              tigerassem.IMOVE{assem="movq %'s0, %'d0",dst="rsi",src="T5"},                  (* movq %T5, %rsi *)
              tigerassem.IOPER{assem="call fact",dst=["rax", "rcx", "rdx", "rsi", "rdi", "r8", "r9"],src=["rdi"],jump=NONE},(* call fact *)
              tigerassem.IMOVE{assem="movq %'s0, %'d0",dst="T7",src="rax"},                  (* movq %rax, %T7 *)
              tigerassem.IMOVE{assem="movq %'s0, %'d0",dst="rax",src="T7"},                  (* movq %T7, %rax *)
              tigerassem.IOPER{assem="jmp 'j0",dst=[],src=[],jump=SOME ["L5"]},              (* jmp L5 *)
              tigerassem.ILABEL{assem="L5:",lab="L5"},                                       (* L5 *)
              tigerassem.IMOVE{assem="movq %'s0, %'d0",dst="rsp",src="rbp"},                 (* movq %rbp, %rsp *)
              tigerassem.IOPER{assem="popq %'d0",dst=["rbp"],src=[],jump=NONE}               (* popq %rbp *)
             ];

(* Probando tigerGraph *)
(* Creo el grafo *)
val graph = tigergraph.newGraph();
(* Agrego 9 nodos *)
val graph = List.foldl (fn (_,g) => #1 (tigergraph.newNode g)) graph [1,2,3,4,5,6,7,8,9];
(* Creo las aristas para agregar *)
val addEdges = [{from=1, to=2},{from=2, to=3},{from=3, to=4},{from=4, to=5},{from=5, to=6},{from=6, to=7},{from=7, to=8},{from=8, to=9}];
(* Agrego las aristas que cree anteriormente *)
val graph = List.foldl (fn (e,g) => tigergraph.mk_edge g e) graph addEdges;
(* Creo las aristas para eliminar *)
val deleteEdges = [{from=2, to=3},{from=4, to=5},{from=6, to=7},{from=8, to=9}];
(* Elimino las aristas que cree anteriormente *)
val graph = List.foldl (fn (e,g) => tigergraph.rm_edge g e) graph deleteEdges;
(* Imprimo el grafo *)
val _ = tigergraph.debugGraph graph;

(* Probando tigerFlow *)
val (fgraph,nodes) = tigerflow.instr2graph instrs;
val _ = tigerflow.debug (fgraph,nodes);

(* Probando funciones de debug de tigerLiveness *)
(* Creamos un nuevo grafo *)
val g = tigergraph.newGraph();
val g = List.foldl (fn (_,grafo) => #1 (tigergraph.newNode grafo)) g [1,2,3,4,5,6,7];
(* Creamos los diccionarios que mapean nodos a temporarios y viceversa *)
val t_TO_n = Splaymap.mkDict String.compare;
val n_TO_t = Splaymap.mkDict Int.compare;
(* Agregamos a los diccionarios los maps correspondientes *)
val maps = [("a",1),("b",2),("c",3),("d",4),("e",5),("f",6),("g",7)];
val t_TO_n = List.foldl (fn ((t,n),d) => Splaymap.insert(d,t,n)) t_TO_n maps;
val n_TO_t = List.foldl (fn ((t,n),d) => Splaymap.insert(d,n,t)) n_TO_t maps;
(* Creamos los moves *)
val m = [(1,7),(3,5)];
(* armamos el igraph *)
val igraph:tigerliveness.igraph = {graph=g,tnode=t_TO_n,gtemp=n_TO_t,moves=m};
(* Probamos las funciones de debug *)
(* Imprimimos la informacion de los mapeos *)
val _ = tigerliveness.debugMaps igraph;
(* Imprimimos el grafo *)
val _ = tigerliveness.debugGraph igraph;
(* Imprimimos la informacion de los moves *)
val _ = tigerliveness.debugMoves igraph;
(* Imprimimos toda la informacion del igraph *)
val _ = tigerliveness.debug igraph;

(* Probando tigerLiveness *)
val (fgraph,nodes) = tigerflow.instr2graph instrs;
val (igraph,liveOut) = tigerliveness.interferenceGraph fgraph;
val _ = tigerliveness.debug igraph;

(* Funcion para imprimir liveOut *)
fun printLiveOut lo =
  let
    fun f (n,set) =
      let
        val _ = print("  -Nodo "^tigergraph.nodename n^": ")
      in
        Splayset.app (fn a => print (a^",")) set;
        print("\n")
      end
  in
    print("###############################################\n");
    print("Imprimiendo liveOut\n");
    print("La informacion se mostrara de la siguiente manera:\n");
    print("-Nodo: temp1, ..., tempn\n");
    List.app f (Splaymap.listItems lo);
    print("\n")
  end;

val _ = printLiveOut liveOut;

(* Funcion para imprimir un set *)
print("set: ")
val _ = Splayset.app (fn a => print(a^",")) !set;
val _ = print("\n");

(* Probando tigerColor *)
val frame = tigerframe.newFrame {name="prueba",formals=[true]};
val (instrucciones,alloc,table) = tigercolor.color (instrs,frame);
val _ = tigercolor.debug (instrucciones,alloc,table);